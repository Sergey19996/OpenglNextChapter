#include "WaterData.h"

 std::unordered_map<uint8_t, uint8_t>WaterData::waterTiles = {

		{0b00000001, 27}, {0b00000010,25}, {0b00000100,24},
		{0b00001000, 11}, {0b00010000,8},  {0b00100000,3},
		{0b01000000, 1}, {0b10000000,0},   {0b10000001,15},
		{0b00100100,23}, {0b10100000,9},   {0b00000101,43},
		{0b00000101,43}, {0b00100001,51},  {0b10000100,59},
		{0b00011000,20}, {0b01000010,29},  {0b10000100,17},
		{0b00100001,10}, {0b10100100,34},  {0b10100001,42},
		{0b00100101,50}, {0b10000101,58},  {0b10100010,36},
		{0b01000101,44}, {0b00110001,52},  {0b10001100,60},
		{0b11010000,62}, {0b01101000,54},  {0b00001011,46},
		{0b00010110,38}, {0b01101100,28},  {0b10001011,4},
		{0b00110110,6}, {0b11010001,30},   {0b10100101,13},
		{0b11111000,37}, {0b00011111,45},  {0b01101011,53},
		{0b11010110,61}, {0b11111111,21},

};

uint8_t WaterData::computeWaterMask(int x, int y, int width, const std::vector<uint8_t>& indices)
{

		auto r = [&](int dx, int dy) {
			int nx = x + dx, ny = y + dy;
			return (nx >= 0 && nx < width && ny >= 0 && ny < indices.size() / width) && indices[ny * width + nx] == WATERIDX;
			};

		return(r(-1, -1) << 0) | (r(0, -1) << 1) | (r(1, -1) << 2) |  // Записываем в каждый бит значения 
			(r(-1, 0) << 3) |                      (r(1, 0) << 4) |
			(r(-1, 1) << 5) |    (r(0, 1) << 6) |  (r(1, 1) << 7);


	};


